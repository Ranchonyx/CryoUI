{
  "version": 3,
  "sources": ["../node_modules/cryo-client-browser/src/Common/AckTracker/AckTracker.ts", "../node_modules/cryo-client-browser/src/Common/CryoBuffer/CryoBuffer.ts", "../node_modules/cryo-client-browser/src/Common/Util/Guard.ts", "../node_modules/cryo-client-browser/src/Common/CryoBinaryMessage/CryoFrameFormatter.ts", "../node_modules/cryo-client-browser/src/Common/CryoFrameInspector/CryoFrameInspector.ts", "../node_modules/cryo-client-browser/src/Common/Util/CreateDebugLogger.ts", "../node_modules/cryo-client-browser/src/Common/CryoEventEmitter/CryoEventEmitter.ts", "../node_modules/cryo-client-browser/src/CryoClientWebsocketSession/CryoCryptoBox.ts", "../node_modules/cryo-client-browser/src/CryoClientWebsocketSession/CryoHandshakeEngine.ts", "../node_modules/cryo-client-browser/src/CryoClientWebsocketSession/CryoFrameRouter.ts", "../node_modules/cryo-client-browser/src/CryoClientWebsocketSession/CryoClientWebsocketSession.ts", "../node_modules/cryo-client-browser/src/index.ts", "../src/frontend.ts"],
  "sourcesContent": ["import {CryoBuffer} from \"../CryoBuffer/CryoBuffer.js\";\n\ntype PendingBinaryMessage = {\n    timestamp: number;\n    message: CryoBuffer;\n    payload?: string | CryoBuffer;\n}\n\nexport class AckTracker {\n    private pending = new Map<number, PendingBinaryMessage>();\n\n    public Track(ack: number, message: PendingBinaryMessage) {\n        this.pending.set(ack, message);\n    }\n\n    public Confirm(ack: number): PendingBinaryMessage | null {\n        const maybe_ack = this.pending.get(ack);\n        if (!maybe_ack)\n            return null;\n\n        this.pending.delete(ack);\n        return maybe_ack;\n    }\n\n    public Has(ack: number): boolean {\n        return this.pending.has(ack);\n    }\n}\n", "export class CryoBuffer {\n    private view: DataView;\n\n    public constructor(public buffer: Uint8Array) {\n        this.view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n    }\n\n    public static alloc(length: number): CryoBuffer {\n        return new CryoBuffer(new Uint8Array(length));\n    }\n\n    public static from(input: string, encoding?: \"utf8\" | \"hex\"): CryoBuffer {\n        if (encoding === \"utf8\")\n            return new CryoBuffer(new TextEncoder().encode(input));\n\n        const data = new Uint8Array(input.length / 2);\n        for (let i = 0; i < data.length; i++)\n            data[i] = parseInt(input.substring(i * 2, i * 2 + 2), 16);\n\n        return new CryoBuffer(data);\n    }\n\n    public static concat(buffers: CryoBuffer[]): CryoBuffer {\n        if (buffers.length === 0)\n            return CryoBuffer.alloc(0);\n\n        const length_total = buffers.reduce((acc, v) => acc + v.length, 0)\n        const result = new Uint8Array(length_total);\n\n        let offset = 0;\n        for (const buf of buffers) {\n            result.set(buf.buffer, offset);\n            offset += buf.length;\n        }\n\n        return new CryoBuffer(result);\n    }\n\n\n    public writeUInt32BE(value: number, offset: number): void {\n        this.view.setUint32(offset, value);\n    }\n\n    public writeUInt8(value: number, offset: number): void {\n        this.view.setUint8(offset, value);\n    }\n\n    public readUInt32BE(offset: number): number {\n        return this.view.getUint32(offset);\n    }\n\n    public readUInt8(offset: number): number {\n        return this.view.getUint8(offset);\n    }\n\n    public write(text: string, offset: number = 0): void {\n        this.buffer.set(new TextEncoder().encode(text), offset);\n    }\n\n    public set(buffer: CryoBuffer, offset: number): void {\n        this.buffer.set(buffer.buffer, offset);\n    }\n\n    public toString(encoding: \"utf8\" | \"hex\"): string {\n        if (encoding === \"utf8\")\n            return new TextDecoder().decode(this.buffer);\n\n        return [...this.buffer]\n            .map(byte => byte.toString(16).padStart(2, \"0\"))\n            .join(\"\");\n    }\n\n    public subarray(start: number, end?: number): CryoBuffer {\n        return new CryoBuffer(this.buffer.subarray(start, end));\n    }\n\n    public copy(target: CryoBuffer, target_start = 0): void {\n        target.buffer.set(this.buffer, target_start);\n    }\n\n    public get length(): number {\n        return this.buffer.byteLength;\n    }\n}\n", "class GuardError extends Error {\n\tconstructor(pMessage: string) {\n\t\tsuper(pMessage);\n\t\tObject.setPrototypeOf(this, GuardError.prototype);\n\t}\n}\n\n/*\n* Helferklasse mit statischen Funktionen zum \"undefined\" und \"null\"-checken, im Wesentlichen fancy asserts und casts.\n* */\nexport default class Guard {\n\t//wenn \"param\" === null, throw with \"message\"\n\tpublic static AgainstNull<T>(param: T, message?: string): asserts param is Exclude<T, null> {\n\t\tif (param === null)\n\t\t\tthrow new GuardError(message ? message : `Assertion failed, \"param\" (${param}) was null!`);\n\t}\n\n\t//Wenn \"param\" === \"undefined\", throw with \"message\"\n\tpublic static AgainstUndefined<T>(param: T, message?: string): asserts param is Exclude<T, undefined> {\n\t\tif (param === undefined)\n\t\t\tthrow new GuardError(message ? message : `Assertion failed, \"param\" (${param}) was undefined!`);\n\t}\n\n\t//Wenn \"param\" === \"null\" or \"param\" === \"undefined\", throw with \"message\"\n\tpublic static AgainstNullish<T>(param: T, message?: string): asserts param is Exclude<Exclude<T, null>, undefined> {\n\t\tGuard.AgainstUndefined(param, message);\n\t\tGuard.AgainstNull(param, message);\n\t}\n\n\t//Typ von \"param\" als Typ \"T\" interpretieren\n\tpublic static CastAs<T>(param: unknown): asserts param is T {\n\t\tGuard.AgainstNullish(param);\n\t}\n\n\t//Typ von \"param\" als Typ \"T\" interpretieren und \"param\" und \"expr\" gegen \"null\" und \"undefined\" guarden\n\tpublic static CastAssert<T>(param: unknown, expr: boolean, message?: string): asserts param is T {\n\t\tGuard.AgainstNullish(param, message);\n\t\tGuard.AgainstNullish(expr, message);\n\t\tif(!expr)\n\t\t\tthrow new GuardError(`Parameter assertion failed in CastAssert!`);\n\t}\n}\n", "import {CryoBuffer} from \"../CryoBuffer/CryoBuffer.js\";\nimport Guard from \"../Util/Guard.js\";\n\ntype UUID = `${string}-${string}-${string}-${string}-${string}`;\ntype Buffer = CryoBuffer;\n\n\nexport enum BinaryMessageType {\n    ACK = 0,\n    ERROR = 1,\n    PING_PONG = 2,\n    UTF8DATA = 3,\n    BINARYDATA = 4,\n    SERVER_HELLO = 5,\n    CLIENT_HELLO = 6,\n    HANDSHAKE_DONE = 7\n}\n\ntype BinaryMessage<T, U extends BinaryMessageType> = {\n    sid: UUID;\n    type: U;\n} & T;\n\ntype AckMessage = BinaryMessage<{\n    ack: number;\n}, BinaryMessageType.ACK>;\n\ntype PingMessage = BinaryMessage<{\n    ack: number;\n    payload: \"ping\" | \"pong\";\n}, BinaryMessageType.PING_PONG>;\n\ntype UTF8DataMessage = BinaryMessage<{\n    ack: number;\n    payload: string;\n}, BinaryMessageType.UTF8DATA>;\n\ntype BinaryDataMessage = BinaryMessage<{\n    ack: number;\n    payload: Buffer;\n}, BinaryMessageType.BINARYDATA>;\n\ntype ErrorMessage = BinaryMessage<{\n    ack: number;\n    payload: \"invalid_operation\" | \"session_expired\" | \"error\";\n}, BinaryMessageType.ERROR>;\n\ntype ServerHelloMessage = BinaryMessage<{\n    ack: number;\n    payload: Buffer;\n}, BinaryMessageType.SERVER_HELLO>\n\ntype ClientHelloMessage = BinaryMessage<{\n    ack: number;\n    payload: Buffer;\n}, BinaryMessageType.CLIENT_HELLO>\n\ntype HandshakeDoneMessage = BinaryMessage<{\n    ack: number;\n    payload: string | null;\n}, BinaryMessageType.HANDSHAKE_DONE>\n\n\ntype CryoAllBinaryMessage =\n    AckMessage\n    | PingMessage\n    | UTF8DataMessage\n    | ErrorMessage\n    | BinaryDataMessage\n    | ServerHelloMessage\n    | ClientHelloMessage\n    | HandshakeDoneMessage;\n\ninterface CryoBinaryFrameFormatter<T extends CryoAllBinaryMessage> {\n    Deserialize(value: Buffer): T;\n\n    Serialize(sid: UUID, ack: number, payload: string | Buffer | null): Buffer;\n}\n\nclass CryoBufferUtil {\n    public static sidFromCryoBuffer(buffer: Buffer): UUID {\n        const uuidv4_p1 = buffer.subarray(0, 4).toString(\"hex\");\n        const uuidv4_p2 = buffer.subarray(4, 6).toString(\"hex\");\n        const uuidv4_p3 = buffer.subarray(6, 8).toString(\"hex\");\n        const uuidv4_p4 = buffer.subarray(8, 10).toString(\"hex\");\n        const uuidv4_p5 = buffer.subarray(10, 16).toString(\"hex\");\n\n        return [uuidv4_p1, uuidv4_p2, uuidv4_p3, uuidv4_p4, uuidv4_p5].join(\"-\") as UUID;\n    }\n\n    public static sidToCryoBuffer(sid: UUID): Buffer {\n        return CryoBuffer.from(sid.replaceAll(\"-\", \"\"), 'hex');\n    }\n}\n\nclass AckFrameFormatter implements CryoBinaryFrameFormatter<AckMessage> {\n    public Deserialize(value: Buffer): AckMessage {\n        const sid = CryoBufferUtil.sidFromCryoBuffer(value);\n        const ack = value.readUInt32BE(16);\n        const type = value.readUInt8(20);\n        if (type !== BinaryMessageType.ACK)\n            throw new Error(\"Attempt to deserialize a non-ack binary message!\");\n\n        return {\n            sid,\n            ack,\n            type\n        }\n    }\n\n    // noinspection JSUnusedLocalSymbols\n    public Serialize(sid: UUID, ack: number, payload: string | Buffer | null = null): Buffer {\n        const msg_buf = CryoBuffer.alloc(16 + 4 + 1);\n        const sid_buf = CryoBufferUtil.sidToCryoBuffer(sid);\n\n        sid_buf.copy(msg_buf, 0);\n        msg_buf.writeUInt32BE(ack, 16);\n        msg_buf.writeUInt8(BinaryMessageType.ACK, 20);\n        return msg_buf;\n    }\n}\n\nclass PingPongFrameFormatter implements CryoBinaryFrameFormatter<PingMessage> {\n    public Deserialize(value: Buffer): PingMessage {\n        const sid = CryoBufferUtil.sidFromCryoBuffer(value);\n        const ack = value.readUInt32BE(16);\n        const type = value.readUInt8(20);\n        const payload = value.subarray(21).toString(\"utf8\");\n        if (type !== BinaryMessageType.PING_PONG)\n            throw new Error(\"Attempt to deserialize a non-ping_pong binary message!\");\n\n        if (!(payload === \"ping\" || payload === \"pong\"))\n            throw new Error(`Invalid payload ${payload} in ping_pong binary message!`);\n\n        return {\n            sid,\n            ack,\n            type,\n            payload\n        }\n    }\n\n    public Serialize(sid: UUID, ack: number, payload: \"ping\" | \"pong\"): Buffer {\n        const msg_buf = CryoBuffer.alloc(16 + 4 + 1 + 4);\n        const sid_buf = CryoBufferUtil.sidToCryoBuffer(sid);\n\n        sid_buf.copy(msg_buf, 0);\n        msg_buf.writeUInt32BE(ack, 16);\n        msg_buf.writeUInt8(BinaryMessageType.PING_PONG, 20);\n        msg_buf.write(payload, 21);\n\n        return msg_buf;\n    }\n}\n\nclass UTF8FrameFormatter implements CryoBinaryFrameFormatter<UTF8DataMessage> {\n    public Deserialize(value: Buffer): UTF8DataMessage {\n        const sid = CryoBufferUtil.sidFromCryoBuffer(value);\n        const ack = value.readUInt32BE(16);\n        const type = value.readUInt8(20);\n        const payload = value.subarray(21).toString(\"utf8\");\n\n        if (type !== BinaryMessageType.UTF8DATA)\n            throw new Error(\"Attempt to deserialize a non-data binary message!\");\n\n        return {\n            sid,\n            ack,\n            type,\n            payload\n        }\n    }\n\n    public Serialize(sid: UUID, ack: number, payload: string | null): Buffer {\n        const msg_buf = CryoBuffer.alloc(16 + 4 + 1 + (payload?.length || 4));\n        const sid_buf = CryoBufferUtil.sidToCryoBuffer(sid);\n\n        sid_buf.copy(msg_buf, 0);\n        msg_buf.writeUInt32BE(ack, 16);\n        msg_buf.writeUInt8(BinaryMessageType.UTF8DATA, 20);\n        msg_buf.write(payload || \"null\", 21);\n\n        return msg_buf;\n    }\n}\n\nclass BinaryFrameFormatter implements CryoBinaryFrameFormatter<BinaryDataMessage> {\n    public Deserialize(value: Buffer): BinaryDataMessage {\n        const sid = CryoBufferUtil.sidFromCryoBuffer(value);\n        const ack = value.readUInt32BE(16);\n        const type = value.readUInt8(20);\n        const payload = value.subarray(21);\n\n        if (type !== BinaryMessageType.BINARYDATA)\n            throw new Error(\"Attempt to deserialize a non-data binary message!\");\n\n        return {\n            sid,\n            ack,\n            type,\n            payload\n        }\n    }\n\n    public Serialize(sid: UUID, ack: number, payload: Buffer | null): Buffer {\n        const payload_length = payload ? payload.length : 4;\n        const msg_buf = CryoBuffer.alloc(16 + 4 + 1 + payload_length);\n        const sid_buf = CryoBufferUtil.sidToCryoBuffer(sid);\n\n        sid_buf.copy(msg_buf, 0);\n        msg_buf.writeUInt32BE(ack, 16);\n        msg_buf.writeUInt8(BinaryMessageType.BINARYDATA, 20);\n        msg_buf.set(payload || CryoBuffer.from(\"null\", \"utf8\"), 21);\n\n        return msg_buf;\n    }\n}\n\nclass ErrorFrameFormatter implements CryoBinaryFrameFormatter<ErrorMessage> {\n    public Deserialize(value: Buffer): ErrorMessage {\n        const sid = CryoBufferUtil.sidFromCryoBuffer(value);\n        const ack = value.readUInt32BE(16);\n        const type = value.readUInt8(20);\n        const payload = value.subarray(21).toString(\"utf8\") as ErrorMessage[\"payload\"];\n\n        if (type !== BinaryMessageType.ERROR)\n            throw new Error(\"Attempt to deserialize a non-error message!\");\n\n        return {\n            sid,\n            ack,\n            type,\n            payload\n        }\n    }\n\n    public Serialize(sid: UUID, ack: number, payload: ErrorMessage[\"payload\"] | null): Buffer {\n        const msg_buf = CryoBuffer.alloc(16 + 4 + 1 + (payload?.length || 13));\n        const sid_buf = CryoBufferUtil.sidToCryoBuffer(sid);\n\n        sid_buf.copy(msg_buf, 0);\n        msg_buf.writeUInt32BE(ack, 16);\n        msg_buf.writeUInt8(BinaryMessageType.ERROR, 20);\n        msg_buf.write(payload || \"unknown_error\", 21);\n\n        return msg_buf;\n    }\n}\n\n\nclass ServerHelloFrameFormatter implements CryoBinaryFrameFormatter<ServerHelloMessage> {\n    public Deserialize(value: Buffer): ServerHelloMessage {\n        const sid = CryoBufferUtil.sidFromCryoBuffer(value);\n        const ack = value.readUInt32BE(16);\n        const type = value.readUInt8(20);\n        const payload = value.subarray(21);\n\n        if (type !== BinaryMessageType.SERVER_HELLO)\n            throw new Error(\"Attempt to deserialize a non-server_hello message!\");\n\n        return {\n            sid,\n            ack,\n            type,\n            payload\n        }\n\n    }\n\n    public Serialize(sid: UUID, ack: number, payload: Buffer | null): Buffer {\n        Guard.CastAssert<Buffer>(payload, payload !== null, \"payload was null!\");\n        if (payload.length !== 65)\n            throw new Error(\"Payload in ServerHelloMessage must be exactly 65 bytes!\");\n\n        const msg_buf = CryoBuffer.alloc(16 + 4 + 1 + 65);\n        const sid_buf = CryoBufferUtil.sidToCryoBuffer(sid);\n\n        sid_buf.copy(msg_buf, 0);\n        msg_buf.writeUInt32BE(ack, 16);\n        msg_buf.writeUInt8(BinaryMessageType.SERVER_HELLO, 20);\n        msg_buf.set(payload, 21);\n\n        return msg_buf;\n    }\n}\n\nclass ClientHelloFrameFormatter implements CryoBinaryFrameFormatter<ClientHelloMessage> {\n    public Deserialize(value: Buffer): ClientHelloMessage {\n        const sid = CryoBufferUtil.sidFromCryoBuffer(value);\n        const ack = value.readUInt32BE(16);\n        const type = value.readUInt8(20);\n        const payload = value.subarray(21);\n\n        if (type !== BinaryMessageType.CLIENT_HELLO)\n            throw new Error(\"Attempt to deserialize a non-client_hello message!\");\n\n        return {\n            sid,\n            ack,\n            type,\n            payload\n        }\n\n    }\n\n    public Serialize(sid: UUID, ack: number, payload: Buffer | null): Buffer {\n        Guard.CastAssert<Buffer>(payload, payload !== null, \"payload was null!\");\n        if (payload.length !== 65)\n            throw new Error(\"Payload in ClientHelloMessage must be exactly 65 bytes!\");\n\n        const msg_buf = CryoBuffer.alloc(16 + 4 + 1 + 65);\n        const sid_buf = CryoBufferUtil.sidToCryoBuffer(sid);\n\n        sid_buf.copy(msg_buf, 0);\n        msg_buf.writeUInt32BE(ack, 16);\n        msg_buf.writeUInt8(BinaryMessageType.CLIENT_HELLO, 20);\n        msg_buf.set(payload, 21);\n\n        return msg_buf;\n    }\n}\n\nclass HandshakeDoneFrameFormatter implements CryoBinaryFrameFormatter<HandshakeDoneMessage> {\n    public Deserialize(value: Buffer): HandshakeDoneMessage {\n        const sid = CryoBufferUtil.sidFromCryoBuffer(value);\n        const ack = value.readUInt32BE(16);\n        const type = value.readUInt8(20);\n        const payload = value.subarray(21).toString(\"utf8\");\n\n        if (type !== BinaryMessageType.HANDSHAKE_DONE)\n            throw new Error(\"Attempt to deserialize a non-handshake_done message!\");\n\n        return {\n            sid,\n            ack,\n            type,\n            payload\n        }\n    }\n\n    public Serialize(sid: UUID, ack: number, payload: string | null): Buffer {\n        const msg_buf = CryoBuffer.alloc(16 + 4 + 1 + (payload?.length || 4));\n        const sid_buf = CryoBufferUtil.sidToCryoBuffer(sid);\n\n        sid_buf.copy(msg_buf, 0);\n        msg_buf.writeUInt32BE(ack, 16);\n        msg_buf.writeUInt8(BinaryMessageType.HANDSHAKE_DONE, 20);\n        msg_buf.write(payload || \"null\", 21);\n\n        return msg_buf;\n    }\n}\n\nexport default class CryoFrameFormatter {\n    public static GetFormatter(type: \"utf8data\"): UTF8FrameFormatter;\n    public static GetFormatter(type: BinaryMessageType.UTF8DATA): UTF8FrameFormatter;\n\n    public static GetFormatter(type: \"ping_pong\"): PingPongFrameFormatter;\n    public static GetFormatter(type: BinaryMessageType.PING_PONG): PingPongFrameFormatter;\n\n    public static GetFormatter(type: \"ack\"): AckFrameFormatter;\n    public static GetFormatter(type: BinaryMessageType.ACK): AckFrameFormatter;\n\n    public static GetFormatter(type: \"error\"): ErrorFrameFormatter;\n    public static GetFormatter(type: BinaryMessageType.ERROR): ErrorFrameFormatter;\n\n    public static GetFormatter(type: \"binarydata\"): BinaryFrameFormatter;\n    public static GetFormatter(type: BinaryMessageType.BINARYDATA): BinaryFrameFormatter;\n\n    public static GetFormatter(type: \"server_hello\"): ServerHelloFrameFormatter;\n    public static GetFormatter(type: BinaryMessageType.SERVER_HELLO): ServerHelloFrameFormatter;\n\n    public static GetFormatter(type: \"client_hello\"): ClientHelloFrameFormatter;\n    public static GetFormatter(type: BinaryMessageType.CLIENT_HELLO): ClientHelloFrameFormatter;\n\n    public static GetFormatter(type: \"handshake_done\"): HandshakeDoneFrameFormatter;\n    public static GetFormatter(type: BinaryMessageType.HANDSHAKE_DONE): HandshakeDoneFrameFormatter;\n\n    public static GetFormatter(type: \"utf8data\" | \"ping_pong\" | \"ack\" | \"error\" | \"binarydata\" | \"server_hello\" | \"client_hello\" | \"handshake_done\"): CryoBinaryFrameFormatter<any>;\n    public static GetFormatter(type:\n                                   BinaryMessageType.UTF8DATA |\n                                   BinaryMessageType.PING_PONG |\n                                   BinaryMessageType.ACK |\n                                   BinaryMessageType.ERROR |\n                                   BinaryMessageType.BINARYDATA |\n                                   BinaryMessageType.SERVER_HELLO |\n                                   BinaryMessageType.CLIENT_HELLO |\n                                   BinaryMessageType.HANDSHAKE_DONE): CryoBinaryFrameFormatter<any>;\n    public static GetFormatter(type: string | BinaryMessageType): CryoBinaryFrameFormatter<CryoAllBinaryMessage> {\n        switch (type) {\n            case \"utf8data\":\n            case BinaryMessageType.UTF8DATA:\n                return new UTF8FrameFormatter();\n            case \"error\":\n            case BinaryMessageType.ERROR:\n                return new ErrorFrameFormatter();\n            case \"ack\":\n            case BinaryMessageType.ACK:\n                return new AckFrameFormatter();\n            case \"ping_pong\":\n            case BinaryMessageType.PING_PONG:\n                return new PingPongFrameFormatter();\n            case \"binarydata\":\n            case BinaryMessageType.BINARYDATA:\n                return new BinaryFrameFormatter();\n            case BinaryMessageType.SERVER_HELLO:\n            case \"server_hello\":\n                return new ServerHelloFrameFormatter();\n            case BinaryMessageType.CLIENT_HELLO:\n            case \"client_hello\":\n                return new ClientHelloFrameFormatter();\n            case BinaryMessageType.HANDSHAKE_DONE:\n            case \"handshake_done\":\n                return new HandshakeDoneFrameFormatter();\n            default:\n                throw new Error(`Binary message format for type '${type}' is not supported!`)\n        }\n    }\n\n    public static GetType(message: Buffer): BinaryMessageType {\n        const type = message.readUInt8(20);\n        if (type > BinaryMessageType.HANDSHAKE_DONE)\n            throw new Error(`Unable to decode type from message ${message}. MAX_TYPE = 7, got ${type} !`);\n\n        return type;\n    }\n\n    public static GetAck(message: Buffer): number {\n        return message.readUInt32BE(16);\n    }\n\n    public static GetSid(message: Buffer): UUID {\n        return CryoBufferUtil.sidFromCryoBuffer(message);\n    }\n\n    public static GetPayload(message: Buffer, encoding: \"utf8\" | \"hex\"): string {\n        return message.subarray(21).toString(encoding);\n    }\n}\n", "import CryoFrameFormatter from \"../CryoBinaryMessage/CryoFrameFormatter.js\";\nimport {CryoBuffer} from \"../CryoBuffer/CryoBuffer.js\";\n\nconst typeToStringMap = {\n    0: \"ack\",\n    1: \"error\",\n    2: \"ping/pong\",\n    3: \"utf8data\",\n    4: \"binarydata\",\n    5: \"server_hello\",\n    6: \"client_hello\",\n    7: \"handshake_done\",\n}\n\nexport class CryoFrameInspector {\n    public static Inspect(message: CryoBuffer, encoding: \"utf8\" | \"hex\" = \"utf8\"): string {\n        const sid = CryoFrameFormatter.GetSid(message);\n        const ack = CryoFrameFormatter.GetAck(message);\n        const type = CryoFrameFormatter.GetType(message);\n        const type_str = typeToStringMap[type] || \"unknown\";\n\n        const payload = CryoFrameFormatter.GetPayload(message, encoding);\n\n        return `[${sid},${ack},${type_str},[${payload}]]`\n    }\n}\n", "export type DebugLoggerFunction = (msg: string, ...params: unknown[]) => void;\n\nexport function CreateDebugLogger(section: string): DebugLoggerFunction {\n    if (localStorage.getItem(\"CRYO_DEBUG\")?.includes(section)) {\n        return (msg: string, ...params: unknown[]) => {\n            const err = new Error();\n            const stack = err.stack?.split(\"\\n\");\n            const caller_line = stack?.[2] ?? \"unknown\";\n            const method_cleaned = caller_line.trim().replace(/^at\\s+/, \"\");\n            const method = method_cleaned.substring(0, method_cleaned.indexOf(\"(\") - 1);\n            const position = method_cleaned.substring(method_cleaned.lastIndexOf(\":\") - 2, method_cleaned.length - 1);\n\n            console.info(`${section.padEnd(24, \" \")}${new Date().toISOString().padEnd(32, \" \")} ${method.padEnd(64, \" \")} ${position.padEnd(8, \" \")} ${msg}`, ...params)\n        }\n    }\n\n    return () => {\n    };\n}\n", "import Guard from \"../Util/Guard.js\";\n\nexport class CryoEventEmitter<EventMap extends Record<string, any> = Record<string, any>> {\n    private target = new EventTarget();\n\n    public on<K extends keyof EventMap>(type: K, listener: (payload: EventMap[K]) => void) {\n        Guard.CastAs<string>(type);\n        this.target.addEventListener(type, (e: Event) => {\n            listener((e as CustomEvent).detail);\n        })\n    }\n\n    public emit<K extends keyof EventMap>(type: K, payload: EventMap[K]) {\n        Guard.CastAs<string>(type);\n        this.target.dispatchEvent(new CustomEvent(type, {detail: payload}));\n    }\n}\n", "import {CryoBuffer} from \"../Common/CryoBuffer/CryoBuffer.js\";\r\n\r\ntype Buffer = CryoBuffer;\r\n\r\nasync function import_key(data: Buffer, usage: KeyUsage[]): Promise<CryptoKey> {\r\n    return crypto.subtle.importKey(\r\n        \"raw\",\r\n        data.buffer,\r\n        {name: \"AES-GCM\"},\r\n        false,\r\n        usage\r\n    );\r\n}\r\n\r\nfunction make_algo(iv: Buffer): AesGcmParams {\r\n    return {\r\n        name: \"AES-GCM\",\r\n        iv: iv.buffer,\r\n\r\n    }\r\n}\r\n\r\nexport class CryoCryptoBox {\r\n    private nonce = 0;\r\n\r\n    private readonly enc_key_promise: Promise<CryptoKey>;\r\n    private readonly dec_key_promise: Promise<CryptoKey>;\r\n\r\n    public constructor(encrypt_key: Buffer, decryption_key: Buffer) {\r\n        this.enc_key_promise = import_key(encrypt_key, [\"encrypt\"]);\r\n        this.dec_key_promise = import_key(decryption_key, [\"decrypt\"]);\r\n    }\r\n\r\n    private create_iv(): Buffer {\r\n        const iv = CryoBuffer.alloc(12);\r\n        iv.writeUInt32BE(this.nonce++, 8);\r\n        return iv;\r\n    }\r\n\r\n    public async encrypt(plain: Buffer): Promise<Buffer> {\r\n        const iv = this.create_iv();\r\n        const key = await this.enc_key_promise;\r\n        const encrypted = await crypto.subtle.encrypt(make_algo(iv), key, plain.buffer);\r\n\r\n        return CryoBuffer.concat([iv, new CryoBuffer(new Uint8Array(encrypted))]);\r\n    }\r\n\r\n    public async decrypt(cipher: Buffer): Promise<CryoBuffer> {\r\n        const iv = cipher.subarray(0, 12);\r\n        const key = await this.dec_key_promise;\r\n        const data_with_tag = cipher.subarray(12);\r\n\r\n        const decrypted = await crypto.subtle.decrypt(make_algo(iv), key, data_with_tag.buffer);\r\n\r\n        return new CryoBuffer(new Uint8Array(decrypted));\r\n    }\r\n}", "import CryoFrameFormatter from \"../Common/CryoBinaryMessage/CryoFrameFormatter.js\";\r\nimport {CryoBuffer} from \"../Common/CryoBuffer/CryoBuffer.js\";\r\n\r\ntype Buffer = CryoBuffer;\r\n\r\nexport enum HandshakeState {\r\n    INITIAL = 0,\r\n    WAIT_SERVER_HELLO = 1,\r\n    WAIT_SERVER_DONE = 2,\r\n    SECURE = 3\r\n}\r\n\r\ntype CryptoKeys = { receive_key: Buffer, transmit_key: Buffer };\r\ntype UUID = `${string}-${string}-${string}-${string}-${string}`;\r\n\r\nexport interface HandshakeEvents {\r\n    onSecure: (keys: CryptoKeys) => void;\r\n    onFailure: (reason: string) => void;\r\n}\r\n\r\nexport class CryoHandshakeEngine {\r\n    private readonly ECDH_ALGO: EcKeyGenParams = {name: \"ECDH\", namedCurve: \"P-256\"};\r\n    private handshake_state: HandshakeState = HandshakeState.INITIAL;\r\n    private ecdh: CryptoKeyPair | null = null;\r\n    private receive_key: Buffer | null = null;\r\n    private transmit_key: Buffer | null = null;\r\n\r\n    public constructor(\r\n        private readonly sid: UUID,\r\n        private send_plain: (buf: Buffer) => Promise<void>,\r\n        private formatter: typeof CryoFrameFormatter,\r\n        private next_ack: () => number,\r\n        private events: HandshakeEvents\r\n    ) {\r\n    }\r\n\r\n    private async init_keys() {\r\n        try {\r\n            this.ecdh = await crypto.subtle.generateKey(\r\n                this.ECDH_ALGO,\r\n                true,\r\n                [\"deriveBits\"]\r\n            );\r\n            this.handshake_state = HandshakeState.WAIT_SERVER_HELLO;\r\n        } catch (ex) {\r\n            this.events.onFailure(`Failed to generate ECDH keys: ${ex}`);\r\n        }\r\n    }\r\n\r\n    public async on_server_hello(frame: Buffer): Promise<void> {\r\n        if (!this.ecdh)\r\n            await this.init_keys();\r\n\r\n        if (this.handshake_state !== HandshakeState.WAIT_SERVER_HELLO) {\r\n            this.events.onFailure(`CLIENT_HELLO received while in state ${this.handshake_state}`);\r\n            return;\r\n        }\r\n\r\n        const decoded = CryoFrameFormatter\r\n            .GetFormatter(\"server_hello\")\r\n            .Deserialize(frame);\r\n\r\n        const server_pub_key = await crypto.subtle.importKey(\"raw\", decoded.payload.buffer, this.ECDH_ALGO, false, []);\r\n\r\n        if (!this.ecdh?.privateKey) {\r\n            this.events.onFailure(\"Local ECDH private key not initialised.\");\r\n            return;\r\n        }\r\n\r\n        const secret = await crypto.subtle.deriveBits({\r\n            name: \"ECDH\",\r\n            public: server_pub_key\r\n        }, this.ecdh.privateKey, 256);\r\n        const hash = new Uint8Array(await crypto.subtle.digest(\"SHA-256\", secret));\r\n\r\n        this.transmit_key = new CryoBuffer(hash.subarray(16, 32));\r\n        this.receive_key = new CryoBuffer(hash.subarray(0, 16));\r\n\r\n        const my_pub_key = new CryoBuffer(new Uint8Array(await crypto.subtle.exportKey(\"raw\", this.ecdh.publicKey)));\r\n\r\n        const ack = this.next_ack();\r\n\r\n        const client_hello = this.formatter\r\n            .GetFormatter(\"client_hello\")\r\n            .Serialize(this.sid, ack, my_pub_key);\r\n\r\n        await this.send_plain(client_hello);\r\n        this.handshake_state = HandshakeState.WAIT_SERVER_DONE;\r\n    }\r\n\r\n    /*\r\n    *         if (this.handshake_state !== HandshakeState.WAIT_SERVER_DONE) {\r\n            this.events.onFailure(`HANDSHAKE_DONE received while in state ${this.state}`);\r\n            return;\r\n        }\r\n        console.error(\"CLIENT GOT SERVER HANDSHAKE!\")\r\n        const decoded = CryoFrameFormatter\r\n            .GetFormatter(\"handshake_done\")\r\n            .Deserialize(frame);\r\n\r\n        const done = CryoFrameFormatter\r\n            .GetFormatter(\"handshake_done\")\r\n            .Serialize(this.sid, decoded.ack, null);\r\n        await this.send_plain(done);\r\n\r\n        this.events.onSecure({receive_key: this.receive_key, transmit_key: this.transmit_key});\r\n        //Client got our SERVER_HELLO and finished on its side\r\n        this.handshake_state = HandshakeState.SECURE;\r\n\r\n    * */\r\n    public async on_server_handshake_done(frame: Buffer): Promise<void> {\r\n        if (this.handshake_state !== HandshakeState.WAIT_SERVER_DONE) {\r\n            this.events.onFailure(`HANDSHAKE_DONE received while in state ${this.state}`);\r\n            return;\r\n        }\r\n\r\n        //Client got our SERVER_HELLO and finished on its side\r\n        //Now we'll send our handshake_done frame\r\n        const decoded = CryoFrameFormatter\r\n            .GetFormatter(\"handshake_done\")\r\n            .Deserialize(frame);\r\n\r\n        const done = CryoFrameFormatter\r\n            .GetFormatter(\"handshake_done\")\r\n            .Serialize(this.sid, decoded.ack, null);\r\n        await this.send_plain(done);\r\n\r\n        this.events.onSecure({receive_key: this.receive_key!, transmit_key: this.transmit_key!});\r\n        this.handshake_state = HandshakeState.SECURE;\r\n    }\r\n\r\n    public get is_secure(): boolean {\r\n        return this.handshake_state === HandshakeState.SECURE;\r\n    }\r\n\r\n    public get state(): HandshakeState {\r\n        return this.handshake_state;\r\n    }\r\n}", "import CryoFrameFormatter, {BinaryMessageType} from \"../Common/CryoBinaryMessage/CryoFrameFormatter.js\";\r\nimport {CreateDebugLogger, DebugLoggerFunction} from \"../Common/Util/CreateDebugLogger.js\";\r\nimport {CryoBuffer} from \"../Common/CryoBuffer/CryoBuffer.js\";\r\ntype Buffer = CryoBuffer;\r\n\r\ninterface RouterHandlers {\r\n    //Normal frame routing\r\n    on_ping_pong: (frame: Buffer) => Promise<void>;\r\n    on_ack: (frame: Buffer) => Promise<void>;\r\n    on_error: (frame: Buffer) => Promise<void>;\r\n    on_utf8: (frame: Buffer) => Promise<void>;\r\n    on_binary: (frame: Buffer) => Promise<void>;\r\n\r\n    //Handshake frame routing should go to the HandshakeEngine\r\n    on_server_hello?: (frame: Buffer) => Promise<void>;\r\n    on_client_hello?: (frame: Buffer) => Promise<void>;\r\n    on_handshake_done?: (frame: Buffer) => Promise<void>;\r\n}\r\n\r\nexport class CryoFrameRouter {\r\n    public constructor(\r\n        private readonly formatter: typeof CryoFrameFormatter,\r\n        private readonly is_secure: () => boolean,\r\n        private readonly decrypt: (buffer: Buffer) => Promise<Buffer>,\r\n        private readonly handlers: RouterHandlers,\r\n        private log: DebugLoggerFunction = CreateDebugLogger(\"CRYO_FRAME_ROUTER\")\r\n    ) {\r\n    }\r\n\r\n    private try_get_type(frame: Buffer): BinaryMessageType | null {\r\n        try {\r\n            return CryoFrameFormatter.GetType(frame);\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n        /*        if(!buf || buf.length < 21)\r\n                    return null;\r\n\r\n                const type_byte = buf.readUint8(20);\r\n                return type_byte <= BinaryMessageType.HANDSHAKE_DONE ? type_byte as BinaryMessageType : null;*/\r\n    }\r\n\r\n    public async do_route(raw: Buffer): Promise<void> {\r\n        let frame: Buffer = raw;\r\n        let type: BinaryMessageType | null = this.try_get_type(raw);\r\n\r\n        if (type === null && this.is_secure()) {\r\n            try {\r\n                frame = await this.decrypt(raw);\r\n                type = this.try_get_type(frame);\r\n            } catch (e) {\r\n                this.log(`Decryption failed: ${e}`, raw);\r\n                return;\r\n            }\r\n        }\r\n\r\n        if (type === null) {\r\n            this.log(`Unknown frame type`, raw);\r\n            return;\r\n        }\r\n\r\n        switch (type) {\r\n            case BinaryMessageType.PING_PONG:\r\n                await this.handlers.on_ping_pong(frame);\r\n                return;\r\n            case BinaryMessageType.ERROR:\r\n                await this.handlers.on_error(frame);\r\n                return;\r\n            case BinaryMessageType.ACK:\r\n                await this.handlers.on_ack(frame);\r\n                return;\r\n            case BinaryMessageType.UTF8DATA:\r\n                await this.handlers.on_utf8(frame);\r\n                return;\r\n            case BinaryMessageType.BINARYDATA:\r\n                await this.handlers.on_binary(frame);\r\n                return;\r\n            case BinaryMessageType.SERVER_HELLO:\r\n                await this.handlers.on_server_hello?.(frame);\r\n                return;\r\n            case BinaryMessageType.CLIENT_HELLO:\r\n                await this.handlers.on_client_hello?.(frame);\r\n                return;\r\n            case BinaryMessageType.HANDSHAKE_DONE:\r\n                await this.handlers.on_handshake_done?.(frame);\r\n                return;\r\n            default:\r\n                this.log(`Unsupported binary message type ${type}!`);\r\n        }\r\n    }\r\n}", "import {ICryoClientWebsocketSessionEvents, PendingBinaryMessage} from \"./types/CryoClientWebsocketSession.js\";\nimport {AckTracker} from \"../Common/AckTracker/AckTracker.js\";\nimport CryoFrameFormatter, {BinaryMessageType} from \"../Common/CryoBinaryMessage/CryoFrameFormatter.js\";\nimport {CryoFrameInspector} from \"../Common/CryoFrameInspector/CryoFrameInspector.js\";\nimport {CreateDebugLogger, DebugLoggerFunction} from \"../Common/Util/CreateDebugLogger.js\";\nimport {CryoBuffer} from \"../Common/CryoBuffer/CryoBuffer.js\";\nimport {CryoEventEmitter} from \"../Common/CryoEventEmitter/CryoEventEmitter.js\";\nimport {CryoCryptoBox} from \"./CryoCryptoBox.js\";\nimport {CryoHandshakeEngine, HandshakeEvents} from \"./CryoHandshakeEngine.js\";\nimport {CryoFrameRouter} from \"./CryoFrameRouter.js\";\n\ntype UUID = `${string}-${string}-${string}-${string}-${string}`;\n\nenum CloseCode {\n    CLOSE_GRACEFUL = 4000,\n    CLOSE_CLIENT_ERROR = 4001,\n    CLOSE_SERVER_ERROR = 4002,\n    CLOSE_CALE_MISMATCH = 4010,\n    CLOSE_CALE_HANDSHAKE = 4011\n}\n\ntype Buffer = CryoBuffer;\n\nfunction once<T extends keyof WebSocketEventMap>(socket: WebSocket, type: T, handler: (ev: WebSocketEventMap[T]) => void) {\n    const wrapper = (ev: WebSocketEventMap[T]) => {\n        socket.removeEventListener(type, wrapper);\n        handler(ev);\n    };\n    socket.addEventListener(type, wrapper);\n}\n\n/*\n* Cryo Websocket session layer. Handles Binary formatting and ACKs and whatnot\n* */\nexport class CryoClientWebsocketSession extends CryoEventEmitter<ICryoClientWebsocketSessionEvents> implements CryoClientWebsocketSession {\n    private messages_pending_server_ack = new Map<number, PendingBinaryMessage>();\n    private server_ack_tracker: AckTracker = new AckTracker();\n    private current_ack = 0;\n\n    private readonly ping_pong_formatter = CryoFrameFormatter.GetFormatter(\"ping_pong\");\n    private readonly ack_formatter = CryoFrameFormatter.GetFormatter(\"ack\");\n    private readonly error_formatter = CryoFrameFormatter.GetFormatter(\"error\");\n    private readonly utf8_formatter = CryoFrameFormatter.GetFormatter(\"utf8data\");\n    private readonly binary_formatter = CryoFrameFormatter.GetFormatter(\"binarydata\");\n\n    private crypto: CryoCryptoBox | null = null;\n    private handshake: CryoHandshakeEngine | null = null;\n    private router: CryoFrameRouter;\n\n    private constructor(private host: string, private sid: UUID, private socket: WebSocket, private timeout: number, private bearer: string, private use_cale: boolean, private log: DebugLoggerFunction = CreateDebugLogger(\"CRYO_CLIENT_SESSION\")) {\n        super();\n        if (use_cale) {\n            const handshake_events: HandshakeEvents = {\n                onSecure: ({transmit_key, receive_key}) => {\n                    this.crypto = new CryoCryptoBox(transmit_key, receive_key);\n                    this.log(\"Channel secured.\");\n                    this.emit(\"connected\", undefined); // only emit once we\u2019re secure\n                },\n                onFailure: (reason: string) => {\n                    this.log(`Handshake failure: ${reason}`);\n                    this.Destroy(CloseCode.CLOSE_CALE_HANDSHAKE, \"Failure during CALE handshake.\");\n                }\n            };\n\n            this.handshake = new CryoHandshakeEngine(\n                this.sid,\n                async (buf) => this.socket.send(buf.buffer), // raw plaintext send\n                CryoFrameFormatter,\n                () => this.current_ack++,\n                handshake_events,\n            );\n\n            this.router = new CryoFrameRouter(\n                CryoFrameFormatter,\n                () => this.handshake!.is_secure,\n                async (b) => this.crypto!.decrypt(b),\n                {\n                    on_ping_pong: async (b) => this.HandlePingPongMessage(b),\n                    on_ack: async (b) => this.HandleAckMessage(b),\n                    on_error: async (b) => this.HandleErrorMessage(b),\n                    on_utf8: async (b) => this.HandleUTF8DataMessage(b),\n                    on_binary: async (b) => this.HandleBinaryDataMessage(b),\n\n                    on_server_hello: async (b) => this.handshake!.on_server_hello(b),\n                    on_handshake_done: async (b) => this.handshake!.on_server_handshake_done(b)\n                }\n            );\n        } else {\n            this.log(\"CALE disabled, running in unencrypted mode.\");\n            this.router = new CryoFrameRouter(\n                CryoFrameFormatter,\n                () => false,\n                async (b) => b,\n                {\n                    on_ping_pong: async (b) => this.HandlePingPongMessage(b),\n                    on_ack: async (b) => this.HandleAckMessage(b),\n                    on_error: async (b) => this.HandleErrorMessage(b),\n                    on_utf8: async (b) => this.HandleUTF8DataMessage(b),\n                    on_binary: async (b) => this.HandleBinaryDataMessage(b),\n                    on_server_hello: async (_b) => this.Destroy(CloseCode.CLOSE_CALE_MISMATCH, \"CALE Mismatch. The server excepts CALE encryption, which is currently disabled.\")\n                }\n            );\n\n            setTimeout(() => this.emit(\"connected\", undefined));\n        }\n\n\n        this.AttachListenersToSocket(socket);\n    }\n\n    private AttachListenersToSocket(socket: WebSocket) {\n        if (this.use_cale) {\n            once(socket, \"message\", (msg: MessageEvent) => {\n                //If the first read frame IS NOT SERVER_HELLO, fail and die in an explosion.\n                if (!(msg.data instanceof ArrayBuffer))\n                    return;\n\n                const raw = new CryoBuffer(new Uint8Array(msg.data));\n                const type = CryoFrameFormatter.GetType(raw);\n\n                if (type !== BinaryMessageType.SERVER_HELLO) {\n                    this.log(`CALE mismatch: expected SERVER_HELLO, got ${type}`);\n                    this.Destroy(CloseCode.CLOSE_CALE_MISMATCH, \"CALE mismatch: The server has disabled CALE.\");\n                    return;\n                }\n\n                this.router.do_route(raw).then(() => {\n                    socket.addEventListener(\"message\", async (msg: MessageEvent) => {\n                        if (msg.data instanceof ArrayBuffer)\n                            await this.router.do_route(new CryoBuffer(new Uint8Array(msg.data)));\n                    });\n                })\n            });\n        } else {\n            socket.addEventListener(\"message\", async (msg: MessageEvent) => {\n                if (msg.data instanceof ArrayBuffer)\n                    await this.router.do_route(new CryoBuffer(new Uint8Array(msg.data)));\n            });\n        }\n\n        socket.addEventListener(\"error\", async (error_event) => {\n            await this.HandleError(new Error(\"Unspecified WebSocket error!\", {cause: error_event}));\n        });\n\n        socket.addEventListener(\"close\", async (close_event) => {\n            await this.HandleClose(close_event.code, new CryoBuffer((new TextEncoder().encode(close_event.reason))));\n        });\n    }\n\n    private static async ConstructSocket(host: string, timeout: number, bearer: string, sid: string): Promise<WebSocket> {\n        const full_host_url = new URL(host);\n        full_host_url.searchParams.set(\"authorization\", `Bearer ${bearer}`);\n        full_host_url.searchParams.set(\"x-cryo-sid\", sid);\n        const sck = new WebSocket(full_host_url);\n        sck.binaryType = \"arraybuffer\";\n\n        return new Promise<WebSocket>((resolve, reject) => {\n            setTimeout(() => {\n                if (sck.readyState !== WebSocket.OPEN)\n                    reject(new Error(`Connection timeout of ${timeout} ms reached!`));\n            }, timeout)\n            sck.addEventListener(\"open\", () => {\n                resolve(sck);\n            })\n            sck.addEventListener(\"error\", (err) => {\n                reject(new Error(`Error during session initialisation!`, {cause: err}));\n            });\n        })\n    }\n\n    public static async Connect(host: string, bearer: string, use_cale: boolean = true, timeout: number = 5000): Promise<CryoClientWebsocketSession> {\n        const sid: UUID = crypto.randomUUID();\n\n        const socket = await CryoClientWebsocketSession.ConstructSocket(host, timeout, bearer, sid);\n        return new CryoClientWebsocketSession(host, sid, socket, timeout, bearer, use_cale);\n    }\n\n    /*\n    * Handle an outgoing binary message\n    * */\n    private async HandleOutgoingBinaryMessage(outgoing_message: CryoBuffer): Promise<void> {\n        if (this.socket.readyState === WebSocket.CLOSING || this.socket.readyState === WebSocket.CLOSED)\n            return;\n\n        //Create a pending message with a new ack number and queue it for acknowledgement by the server\n        const type = CryoFrameFormatter.GetType(outgoing_message);\n        if (type === BinaryMessageType.UTF8DATA || type === BinaryMessageType.BINARYDATA) {\n            const message_ack = CryoFrameFormatter.GetAck(outgoing_message);\n            this.server_ack_tracker.Track(message_ack, {\n                timestamp: Date.now(),\n                message: outgoing_message\n            });\n        }\n\n        //Send the message buffer to the server\n        if (!this.socket)\n            return;\n\n        let message = outgoing_message;\n        if (this.use_cale && this.secure) {\n            message = await this.crypto!.encrypt(outgoing_message);\n        }\n\n        try {\n            this.socket.send(message.buffer);\n        } catch (ex) {\n            if (ex instanceof Error)\n                this.HandleError(ex).then(r => null);\n        }\n\n        this.log(`Sent ${CryoFrameInspector.Inspect(outgoing_message)} to server.`);\n\n\n    }\n\n    /*\n    * Respond to PONG frames with PING and vice versa\n    * */\n    private async HandlePingPongMessage(message: CryoBuffer): Promise<void> {\n        const decodedPingPongMessage = this.ping_pong_formatter\n            .Deserialize(message);\n\n        const ping_pongMessage = this.ping_pong_formatter\n            .Serialize(this.sid, decodedPingPongMessage.ack, decodedPingPongMessage.payload === \"pong\" ? \"ping\" : \"pong\");\n\n        await this.HandleOutgoingBinaryMessage(ping_pongMessage);\n    }\n\n    /*\n    * Handling of binary error messages from the server, currently just log it\n    * */\n    private async HandleErrorMessage(message: CryoBuffer): Promise<void> {\n        const decodedErrorMessage = this.error_formatter\n            .Deserialize(message);\n\n        this.log(decodedErrorMessage.payload);\n    }\n\n    /*\n    * Locally ACK the pending message if it matches the server's ACK\n    * */\n    private async HandleAckMessage(message: Buffer): Promise<void> {\n        const decodedAckMessage = this.ack_formatter\n            .Deserialize(message);\n        const ack_id = decodedAckMessage.ack;\n\n        const found_message = this.server_ack_tracker.Confirm(ack_id);\n\n        if (!found_message) {\n            this.log(`Got unknown ack_id ${ack_id} from server.`);\n            return;\n        }\n\n        this.messages_pending_server_ack.delete(ack_id);\n        this.log(`Got ACK ${ack_id} from server.`);\n    }\n\n    /*\n    * Extract payload from the binary message and emit the message event with the utf8 payload\n    * */\n    private async HandleUTF8DataMessage(message: Buffer): Promise<void> {\n        const decodedDataMessage = this.utf8_formatter\n            .Deserialize(message);\n\n        const payload = decodedDataMessage.payload;\n\n        const encodedAckMessage = this.ack_formatter\n            .Serialize(this.sid, decodedDataMessage.ack);\n\n        await this.HandleOutgoingBinaryMessage(encodedAckMessage);\n        this.emit(\"message-utf8\", payload);\n    }\n\n    /*\n    * Extract payload from the binary message and emit the message event with the binary payload\n    * */\n    private async HandleBinaryDataMessage(message: Buffer): Promise<void> {\n        const decodedDataMessage = this.binary_formatter\n            .Deserialize(message);\n\n        const payload = decodedDataMessage.payload;\n\n        const encodedAckMessage = this.ack_formatter\n            .Serialize(this.sid, decodedDataMessage.ack);\n\n        await this.HandleOutgoingBinaryMessage(encodedAckMessage);\n        this.emit(\"message-binary\", payload);\n    }\n\n    private async HandleError(err: Error) {\n        this.log(`${err.name} Exception in CryoSocket: ${err.message}`);\n        this.socket.close(CloseCode.CLOSE_SERVER_ERROR, `CryoSocket ${this.sid} was closed due to an error.`);\n    }\n\n    private TranslateCloseCode(code: number): string {\n        switch (code as CloseCode) {\n            case CloseCode.CLOSE_GRACEFUL:\n                return \"Connection closed normally.\";\n            case CloseCode.CLOSE_CLIENT_ERROR:\n                return \"Connection closed due to a client error.\";\n            case CloseCode.CLOSE_SERVER_ERROR:\n                return \"Connection closed due to a server error.\";\n            case CloseCode.CLOSE_CALE_MISMATCH:\n                return \"Connection closed due to a mismatch in client/server CALE configuration.\";\n            case CloseCode.CLOSE_CALE_HANDSHAKE:\n                return \"Connection closed due to an error in the CALE handshake.\";\n            default:\n                return \"Unspecified cause for connection closure.\"\n        }\n    }\n\n    private async HandleClose(code: number, reason: Buffer) {\n        console.warn(`Websocket was closed. Code=${code} (${this.TranslateCloseCode(code)}), reason=${reason.toString(\"utf8\")}.`);\n\n        if (code !== CloseCode.CLOSE_SERVER_ERROR)\n            return;\n\n        let current_attempt = 0;\n        let back_off_delay = 5000;\n\n        //If the connection was not normally closed, try to reconnect\n        console.error(`Abnormal termination of Websocket connection, attempting to reconnect...`);\n        ///@ts-expect-error\n        this.socket = null;\n\n        this.emit(\"disconnected\", undefined)\n        while (current_attempt < 5) {\n            try {\n                this.socket = await CryoClientWebsocketSession.ConstructSocket(this.host, this.timeout, this.bearer, this.sid);\n                this.AttachListenersToSocket(this.socket);\n\n                this.emit(\"reconnected\", undefined);\n                return;\n            } catch (ex) {\n                if (ex instanceof Error) {\n                    ///@ts-expect-error\n                    const errorCode = ex.cause?.error?.code as string;\n                    console.warn(`Unable to reconnect to '${this.host}'. Error code: '${errorCode}'. Retry attempt in ${back_off_delay} ms. Attempt ${current_attempt++} / 5`);\n                    await new Promise((resolve) => setTimeout(resolve, back_off_delay));\n                    back_off_delay += current_attempt * 1000;\n                }\n            }\n        }\n\n        console.error(`Gave up on reconnecting to '${this.host}'`);\n\n        if (this.socket)\n            this.socket.close();\n\n        this.emit(\"closed\", [code, reason.toString(\"utf8\")]);\n    }\n\n    /*\n    * Send an utf8 message to the server\n    * */\n    public async SendUTF8(message: string): Promise<void> {\n        const new_ack_id = this.current_ack++;\n\n        const formatted_message = CryoFrameFormatter\n            .GetFormatter(\"utf8data\")\n            .Serialize(this.sid, new_ack_id, message);\n\n        await this.HandleOutgoingBinaryMessage(formatted_message);\n    }\n\n    /*\n    * Send a binary message to the server\n    * */\n    public async SendBinary(message: CryoBuffer): Promise<void> {\n        const new_ack_id = this.current_ack++;\n\n        const formatted_message = CryoFrameFormatter\n            .GetFormatter(\"binarydata\")\n            .Serialize(this.sid, new_ack_id, message);\n\n        await this.HandleOutgoingBinaryMessage(formatted_message);\n    }\n\n    public Close(): void {\n        this.Destroy(CloseCode.CLOSE_GRACEFUL, \"Client finished.\");\n    }\n\n    public get secure(): boolean {\n        return this.use_cale && this.crypto !== null;\n    }\n\n    public get session_id(): UUID {\n        return this.sid;\n    }\n\n    public Destroy(code: number = 1000, message: string = \"\") {\n        this.log(`Teardown of session. Code=${code}, reason=${message}`);\n        this.socket.close(code, message);\n    }\n}\n", "import {CryoClientWebsocketSession} from \"./CryoClientWebsocketSession/CryoClientWebsocketSession.js\";\n\n/**\n * Create a Cryo client\n * @param host - The server to connect to\n * @param bearer - The Bearer token for the server to validate\n * @param use_cale - If cALE (application layer encryption) should be enabled\n * @param timeout - How long to wait until the client stops establishing a connection\n * */\nexport async function cryo(host: string, bearer: string, use_cale: boolean, timeout: number = 5000) {\n    return CryoClientWebsocketSession.Connect(host, bearer, use_cale, timeout);\n}", "import {cryo, CryoClientWebsocketSession} from \"cryo-client-browser\"\r\n\r\nasync function onConnected(client: CryoClientWebsocketSession) {\r\n    console.log(\"Connected to backend.\");\r\n    console.log(\"Connected to backend.\");\r\n\r\n}\r\n\r\ndocument.addEventListener(\"DOMContentLoaded\", async () => {\r\n    const client = await cryo(\"localhost:8080\", \"test\", false);\r\n    client.on(\"connected\", async () => {\r\n        await onConnected(client);\r\n    })\r\n})"],
  "mappings": "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",
  "names": ["AckTracker", "ack", "message", "maybe_ack", "CryoBuffer", "_CryoBuffer", "buffer", "length", "input", "encoding", "data", "i", "buffers", "length_total", "acc", "v", "result", "offset", "buf", "value", "text", "byte", "start", "end", "target", "target_start", "GuardError", "_GuardError", "pMessage", "Guard", "_Guard", "param", "expr", "CryoBufferUtil", "uuidv4_p1", "uuidv4_p2", "uuidv4_p3", "uuidv4_p4", "uuidv4_p5", "sid", "AckFrameFormatter", "type", "payload", "msg_buf", "PingPongFrameFormatter", "UTF8FrameFormatter", "BinaryFrameFormatter", "payload_length", "ErrorFrameFormatter", "ServerHelloFrameFormatter", "ClientHelloFrameFormatter", "HandshakeDoneFrameFormatter", "CryoFrameFormatter", "typeToStringMap", "CryoFrameInspector", "type_str", "CreateDebugLogger", "section", "msg", "params", "method_cleaned", "method", "position", "CryoEventEmitter", "listener", "e", "import_key", "usage", "make_algo", "iv", "CryoCryptoBox", "encrypt_key", "decryption_key", "plain", "key", "encrypted", "cipher", "data_with_tag", "decrypted", "CryoHandshakeEngine", "send_plain", "formatter", "next_ack", "events", "ex", "frame", "decoded", "server_pub_key", "secret", "hash", "my_pub_key", "client_hello", "done", "CryoFrameRouter", "is_secure", "decrypt", "handlers", "log", "raw", "once", "socket", "handler", "wrapper", "ev", "CryoClientWebsocketSession", "_CryoClientWebsocketSession", "host", "timeout", "bearer", "use_cale", "handshake_events", "transmit_key", "receive_key", "reason", "b", "_b", "error_event", "close_event", "full_host_url", "sck", "resolve", "reject", "err", "outgoing_message", "message_ack", "r", "decodedPingPongMessage", "ping_pongMessage", "decodedErrorMessage", "ack_id", "decodedDataMessage", "encodedAckMessage", "code", "current_attempt", "back_off_delay", "errorCode", "new_ack_id", "formatted_message", "cryo"]
}
